package com.dazzle.asklepios.web.rest;

import com.dazzle.asklepios.domain.DiagnosticTest;
import com.dazzle.asklepios.domain.Practitioner;
import com.dazzle.asklepios.domain.enumeration.Specialty;
import com.dazzle.asklepios.service.PractitionerService;
import com.dazzle.asklepios.web.rest.Helper.PaginationUtil;
import com.dazzle.asklepios.web.rest.vm.diagnostictest.DiagnosticTestResponseVM;
import com.dazzle.asklepios.web.rest.vm.practitioner.PractitionerCreateVM;
import com.dazzle.asklepios.web.rest.vm.practitioner.PractitionerResponseVM;
import com.dazzle.asklepios.web.rest.vm.practitioner.PractitionerUpdateVM;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springdoc.core.annotations.ParameterObject;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/api/setup")
public class PractitionerController {

    private static final Logger LOG = LoggerFactory.getLogger(PractitionerController.class);

    private final PractitionerService practitionerService;

    public PractitionerController(PractitionerService practitionerService) {
        this.practitionerService = practitionerService;
    }

    /**
     * {@code POST /practitioner} : Create a new Practitioner.
     *
     * <p>Validates the payload, persists the entity, and returns a response model.</p>
     *
     * @param practitionerVM the creation payload.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and body of the created practitioner,
     *         with a {@code Location} header pointing to the new resource;
     *         or {@code 400 (Bad Request)} if the payload is invalid.
     */
    @PostMapping("/practitioner")
    public ResponseEntity<PractitionerResponseVM> createPractitioner(@Valid @RequestBody PractitionerCreateVM practitionerVM) {
        LOG.debug("REST create Practitioner payload={}", practitionerVM);
        Practitioner practitioner = practitionerService.create(practitionerVM);
        PractitionerResponseVM response = PractitionerResponseVM.ofEntity(practitioner);
        LOG.debug("REST create Practitioner response={}", response);

        return ResponseEntity
                .created(URI.create("/api/setup/practitioner/" + practitioner.getId()))
                .body(response);
    }

    /**
     * {@code PUT /practitioner/{id}} : Update an existing Practitioner.
     *
     * <p>Updates mutable fields of the practitioner identified by {@code id}.</p>
     *
     * @param id the identifier of the practitioner to update.
     * @param practitionerUpdateVM the update payload.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the updated practitioner in the body,
     *         or {@code 404 (Not Found)} if no practitioner exists with the given {@code id}.
     */
    @PutMapping("/practitioner/{id}")
    public ResponseEntity<PractitionerResponseVM> updatePractitioner(@Valid@PathVariable Long id, @Valid @RequestBody PractitionerUpdateVM practitionerUpdateVM) {
        LOG.debug("REST update Practitioner id={} payload={}", id, practitionerUpdateVM);
        return practitionerService.update(id, practitionerUpdateVM)
                .map(p -> ResponseEntity.ok(PractitionerResponseVM.ofEntity(p)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    /**
     * {@code GET /practitioner} : Get a paginated list of all Practitioners.
     *
     * <p>Supports standard Spring pagination parameters: {@code page}, {@code size}, and {@code sort}.</p>
     *
     * <p>Response includes pagination headers generated by {@link PaginationUtil}:
     * {@code X-Total-Count} and {@code Link} for navigation.</p>
     *
     * @param pageable the pagination and sorting information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)}, a list of practitioner view models in the body,
     *         and pagination headers.
     */
    @GetMapping("/practitioner")
    public ResponseEntity<List<PractitionerResponseVM>> getAllPractitioners(@ParameterObject Pageable pageable) {
        LOG.debug("REST list Practitioners page={}", pageable);
        Page<Practitioner> page = practitionerService.findAll(pageable);
        LOG.debug("REST list Practitioners results={}", page.getContent());
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return new ResponseEntity<>(page.getContent().stream().map(PractitionerResponseVM::ofEntity).toList(), headers, HttpStatus.OK);
    }

    /**
     * {@code GET /practitioner/by-facility/{facilityId}} : Get practitioners for a facility (paginated).
     *
     * <p>Returns practitioners that belong to the facility with id {@code facilityId}.</p>
     *
     * <p>Includes pagination headers {@code X-Total-Count} and {@code Link}.</p>
     *
     * @param facilityId the facility identifier.
     * @param pageable pagination and sorting information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and a list of practitioner view models,
     *         plus pagination headers.
     */
    @GetMapping("/practitioner/by-facility/{facilityId:\\d+}")
    public ResponseEntity<List<PractitionerResponseVM>> getByFacility(
            @PathVariable Long facilityId,
            @ParameterObject Pageable pageable) {

        LOG.debug("REST list Practitioners by facilityId={} page={}", facilityId, pageable);
        Page<Practitioner> page = practitionerService.findByFacilityId(facilityId, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return new ResponseEntity<>(page.getContent().stream().map(PractitionerResponseVM::ofEntity).toList(), headers, HttpStatus.OK);
    }

    /**
     * {@code GET /practitioner/by-specialty/{specialty}} : Get practitioners by specialty (paginated).
     *
     * @param specialty the specialty to filter by.
     * @param pageable pagination and sorting information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and a list of practitioner view models.
     */
    @GetMapping("/practitioner/by-specialty/{specialty}")
    public ResponseEntity<List<PractitionerResponseVM>> getBySpecialty(
            @PathVariable Specialty specialty,
            @ParameterObject Pageable pageable) {

        LOG.debug("REST list Practitioners by specialty={} page={}", specialty, pageable);
        Page<Practitioner> page = practitionerService.findBySpecialty(specialty, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return new ResponseEntity<>(page.getContent().stream().map(PractitionerResponseVM::ofEntity).toList(), headers, HttpStatus.OK);
    }

    /**
     * {@code GET /practitioner/{id}} : Get a single Practitioner by id.
     *
     * @param id the identifier of the practitioner to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the practitioner view model,
     *         or {@code 404 (Not Found)} if the practitioner does not exist.
     */
    @GetMapping("/practitioner/{id}")
    public ResponseEntity<PractitionerResponseVM> getPractitioner(@PathVariable Long id) {
        LOG.debug("REST get Practitioner id={}", id);
        return practitionerService.findOne(id)
                .map(PractitionerResponseVM::ofEntity)
                .map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }


    /**
     * Search practitioner by name (case-insensitive).
     */
    @GetMapping("/practitioner/by-name/{name}")
    public ResponseEntity<List<PractitionerResponseVM>> findByName(@PathVariable String name, @ParameterObject Pageable pageable) {
        LOG.debug("REST request to search Practitioner by name='{}' page={}", name, pageable);
        Page<Practitioner> page = practitionerService.findByFirstNameOrLastName(name,pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        LOG.debug("REST found {} Practitioner matching name='{}'", page.getTotalElements(), name);
        return new ResponseEntity<>(page.getContent().stream().map(PractitionerResponseVM::ofEntity).toList(), headers, HttpStatus.OK);
    }

    /**
     * {@code PATCH /practitioner/{id}/toggle-active} : Toggle the {@code isActive} status of a Practitioner.
     *
     * <p>Flips the active flag for the practitioner identified by {@code id} and returns the updated resource.</p>
     *
     * @param id the identifier of the practitioner to toggle.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the updated practitioner view model,
     *         or {@code 404 (Not Found)} if the practitioner does not exist.
     */
    @PatchMapping("/practitioner/{id}/toggle-active")
    public ResponseEntity<PractitionerResponseVM> togglePractitionerActiveStatus(@PathVariable Long id) {
        LOG.debug("REST toggle Practitioner isActive id={}", id);
        return practitionerService.toggleIsActive(id)
                .map(PractitionerResponseVM::ofEntity)
                .map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}
