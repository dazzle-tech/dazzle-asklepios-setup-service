package com.dazzle.asklepios.web.rest;

import com.dazzle.asklepios.domain.ActiveIngredients;
import com.dazzle.asklepios.service.ActiveIngredientsService;
import com.dazzle.asklepios.web.rest.Helper.PaginationUtil;
import com.dazzle.asklepios.web.rest.vm.activeIngredients.ActiveIngredientsCreateVM;
import com.dazzle.asklepios.web.rest.vm.activeIngredients.ActiveIngredientsResponseVM;
import com.dazzle.asklepios.web.rest.vm.activeIngredients.ActiveIngredientsUpdateVM;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springdoc.core.annotations.ParameterObject;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/api/setup")
public class ActiveIngredientsController {

    private static final Logger LOG = LoggerFactory.getLogger(ActiveIngredientsController.class);

    private final ActiveIngredientsService activeIngredientsService;

    public ActiveIngredientsController(ActiveIngredientsService activeIngredientsService) {
        this.activeIngredientsService = activeIngredientsService;
    }

    /**
     * {@code POST /active-ingredients} : Create a new active ingredient.
     *
     * <p>Validates the payload, persists the entity, and returns a response model.</p>
     *
     * @param activeIngredientsCreateVM the creation payload.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and body of the created active ingredient,
     *         with a {@code Location} header pointing to the new resource;
     *         or {@code 400 (Bad Request)} if the payload is invalid
     *         or {@code 400 (Bad Request) if the active ingredient name already exist}
     *         or  {@code 404 (Not Found)} if no medical category or  medical category class  exists with the given {@code vm.medicalCategoryId / vm.drugClassId}.
     */
    @PostMapping("/active-ingredients")
    public ResponseEntity<ActiveIngredientsResponseVM> createActiveIngredient(@Valid @RequestBody ActiveIngredientsCreateVM activeIngredientsCreateVM) {
        LOG.debug("REST create ActiveIngredients payload={}", activeIngredientsCreateVM);
        ActiveIngredients saved = activeIngredientsService.create(activeIngredientsCreateVM);
        ActiveIngredientsResponseVM body = ActiveIngredientsResponseVM.ofEntity(saved);

        return ResponseEntity
                .created(URI.create("/setup/api/active-ingredients/" + saved.getId()))
                .body(body);
    }

    /**
     * {@code PUT /active-ingredients/{id}} : Update an existing ActiveIngredients.
     *
     * <p>Updates mutable fields of the active ingredient identified by {@code id}.</p>
     *
     * @param id the identifier of the active ingredient to update.
     * @param activeIngredientsUpdateVM the update payload.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the updated active ingredient in the body,
     *         or {@code 404 (Not Found)} if no active ingredient exists with the given {@code id}
     *         or {@code 400 (Bad Request) if the active ingredient name already exist}
     *         or  {@code 404 (Not Found)} if no medical category or  medical category class  exists with the given {@code vm.medicalCategoryId / vm.drugClassId}.
     */
    @PutMapping("/active-ingredients/{id}")
    public ResponseEntity<ActiveIngredientsResponseVM> update(@PathVariable Long id, @Valid @RequestBody ActiveIngredientsUpdateVM activeIngredientsUpdateVM) {
        LOG.debug("REST update ActiveIngredients id={} payload={}", id, activeIngredientsUpdateVM);
        if (activeIngredientsUpdateVM.id() == null || !id.equals(activeIngredientsUpdateVM.id())) {
            return ResponseEntity.badRequest().build();
        }
        ActiveIngredients updated = activeIngredientsService.update(activeIngredientsUpdateVM);
        return ResponseEntity.ok(ActiveIngredientsResponseVM.ofEntity(updated));
    }

    /**
     * {@code GET /active-ingredients} : Get a paginated list of all Active Ingredients.
     *
     * <p>Supports standard Spring pagination parameters:
     * {@code page}, {@code size}, and {@code sort} (e.g. {@code sort=name,asc}).</p>
     *
     * <p>Response includes pagination headers generated by {@link PaginationUtil}:
     * {@code X-Total-Count} and {@code Link} for navigation.</p>
     *
     * @param pageable the pagination and sorting information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)}, a list of active ingredients view models in the body,
     *         and pagination headers.
     */
    @GetMapping("/active-ingredients")
    public ResponseEntity<List<ActiveIngredientsResponseVM>> getAll(@ParameterObject Pageable pageable) {
        LOG.debug("REST list ActiveIngredients page={}", pageable);
        Page<ActiveIngredients> page = activeIngredientsService.getAll(pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page
        );
        List<ActiveIngredientsResponseVM> body = page.getContent()
                .stream().map(ActiveIngredientsResponseVM::ofEntity).toList();
        return new ResponseEntity<>(body, headers, HttpStatus.OK);
    }

    /**
     * {@code GET /active-ingredients/by-name/{name}} : Get active ingredients by name (paginated).
     *
     * <p>Returns active ingredients that contain the name with {@code name}.</p>
     *
     * <p>Includes pagination headers {@code X-Total-Count} and {@code Link}.</p>
     *
     * @param name the name identifier.
     * @param pageable   pagination and sorting information.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and a list of active ingredients view models,
     *         plus pagination headers. Returns an empty list if none found.
     */
    @GetMapping("/active-ingredients/by-name/{name}")
    public ResponseEntity<List<ActiveIngredientsResponseVM>> getByName(@PathVariable String name, @ParameterObject Pageable pageable) {
        LOG.debug("REST list ActiveIngredients by name='{}' page={}", name, pageable);
        Page<ActiveIngredients> page = activeIngredientsService.getByName(name, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        List<ActiveIngredientsResponseVM> body = page.getContent()
                .stream().map(ActiveIngredientsResponseVM::ofEntity).toList();
        return new ResponseEntity<>(body, headers, HttpStatus.OK);
    }

    /**
     * {@code GET /active-ingredients/by-medicalCategory/{categoryId}} : Filter by medical category id (paginated).
     */
    @GetMapping("/active-ingredients/by-medicalCategory/{categoryId:\\d+}")
    public ResponseEntity<List<ActiveIngredientsResponseVM>> getByMedicalCategory(@PathVariable Long categoryId, @ParameterObject Pageable pageable) {
        LOG.debug("REST list ActiveIngredients by medicalCategoryId={} page={}", categoryId, pageable);
        Page<ActiveIngredients> page = activeIngredientsService.getByMedicalCategoryId(categoryId, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        List<ActiveIngredientsResponseVM> body = page.getContent()
                .stream().map(ActiveIngredientsResponseVM::ofEntity).toList();
        return new ResponseEntity<>(body, headers, HttpStatus.OK);
    }

    /**
     * {@code GET /active-ingredients/by-drugClass/{drugClassId}} : Filter by drug class id (paginated).
     */
    @GetMapping("/active-ingredients/by-drugClass/{drugClassId:\\d+}")
    public ResponseEntity<List<ActiveIngredientsResponseVM>> getByDrugClass(@PathVariable Long drugClassId, @ParameterObject Pageable pageable) {
        LOG.debug("REST list ActiveIngredients by drugClassId={} page={}", drugClassId, pageable);
        Page<ActiveIngredients> page = activeIngredientsService.getByDrugClassId(drugClassId, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        List<ActiveIngredientsResponseVM> body = page.getContent()
                .stream().map(ActiveIngredientsResponseVM::ofEntity).toList();
        return new ResponseEntity<>(body, headers, HttpStatus.OK);
    }

    /**
     * {@code GET /active-ingredients/by-atc/{atcCode}} : Search by ATC code (contains, ignore case).
     */
    @GetMapping("/active-ingredients/by-atc/{atcCode}")
    public ResponseEntity<List<ActiveIngredientsResponseVM>> getByAtcCode(@PathVariable String atcCode, @ParameterObject Pageable pageable) {
        LOG.debug("REST list ActiveIngredients by atcCode='{}' page={}", atcCode, pageable);
        Page<ActiveIngredients> page = activeIngredientsService.getByAtcCode(atcCode, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        List<ActiveIngredientsResponseVM> body = page.getContent()
                .stream().map(ActiveIngredientsResponseVM::ofEntity).toList();
        return new ResponseEntity<>(body, headers, HttpStatus.OK);
    }

    /**
     * {@code PATCH /active-ingredients/{id}/toggle-active} : Toggle the {@code isActive} status of an active ingredient.
     *
     * <p>Flips the active flag for the active ingredient identified by {@code id} and returns the updated resource.</p>
     *
     * @param id the identifier of the active ingredient to toggle.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the updated active ingredient view model,
     *         or {@code 404 (Not Found)} if the active ingredient does not exist.
     */
    @PatchMapping("/active-ingredients/{id}/toggle-active")
    public ResponseEntity<ActiveIngredientsResponseVM> toggleActive(@PathVariable Long id) {
        LOG.debug("REST toggle ActiveIngredients isActive id={}", id);
        ActiveIngredients updated = activeIngredientsService.toggleActive(id);
        return ResponseEntity.ok(ActiveIngredientsResponseVM.ofEntity(updated));
    }
}
